
import copy
import os

from calibtool.CalibManager import CalibManager
from calibtool.algorithms.OptimTool import OptimTool
from calibtool.plotters.LikelihoodPlotter import LikelihoodPlotter
from calibtool.plotters.OptimToolPlotter import OptimToolPlotter
from calibtool.plotters.SiteDataPlotter import SiteDataPlotter
from dtk.utils.core.DTKConfigBuilder import DTKConfigBuilder
from simtools.SetupParser import SetupParser

from ImmunityCalibSite import ImmunityCalibSite


SetupParser.default_block = 'HPC'

cb = DTKConfigBuilder.from_defaults('MALARIA_SIM')

#Set immunity calib site configurations for this calibration attempt

#timespans in years
analyze_duration  = 0.5
run_duration = 30
start_analysis = 25
#number of infections to be delivered
n_infections = 10

#Calibration details
expname = 'ImmunityCalib_10inf_new_guesses'
max_iterations = 15
samples_per_iteration = 100

project_path = os.getcwd()
reference_fname = os.path.join(project_path, 'inputs','InsetChart_Base.json')

sites = [ImmunityCalibSite(reference_fname=reference_fname, run_duration = run_duration,
                           analyze_duration = analyze_duration, start_analysis=start_analysis,
                           n_infections=n_infections)
         ]
# The default plotters used in an Optimization with OptimTool
plotters = [LikelihoodPlotter(combine_sites=True),
            SiteDataPlotter(num_to_plot=5, combine_sites=True),
            OptimToolPlotter()  # OTP must be last because it calls gc.collect()
]


params = [
    {
        'Name': 'Falciparum_PfEMP1_Variants',
        'Dynamic': True,
        'Guess': 1070,
        'Min': 1000,
        'Max': 5000
    },
    {
        'Name': 'Antibody_Memory_Level',
        'Dynamic': True,
        'Guess': 0.15,
        'Min': 0,
        'Max': 0.35
    },
    {
        'Name': 'Hyperimmunity_Halflife',
        'Dynamic': True,
        'Guess': 35,
        'Min': 10,
        'Max': 100
    }
]


def constrain_sample(sample):

    return sample


def map_sample_to_model_input(cb, sample):
    """
    This method needs to map the samples generated by the next point algorithm to the model inputs (represented here by the cb).
    It is important to note that the sample may be shared by several isntances of this function.
    Therefore it is important to deepcopy the sample at the beginning if we intend to modify it (by calling .pop() for example).
       sample = copy.deepcopy(sample)
    :param cb: The config builder representing the model inputs for this particular simulation
    :param sample: The sample containing a values for all the params. e.g. {'Clinical Fever Threshold High':1, ... }
    :return: A dictionary containing the tags that will be attached to the simulation
    """
    tags = {}
    # Make a copy of samples so we can alter it safely
    sample = copy.deepcopy(sample)

    # Can perform custom mapping, e.g. a trivial example
    if 'Parasite_Severe_Threshold' in sample:
        value = sample.pop('Parasite_Severe_Threshold')
        tags.update(cb.set_param('Parasite_Severe_Threshold', 10**value))

    for p in params:
        if p['Name'] == 'Falciparum_PfEMP1_Variants':
            value = int(sample.pop(p['Name']))
            tags.update(cb.set_param(p['Name'], value))

        elif not p['Name'] == 'Parasite_Severe_Threshold':
            value = sample.pop(p['Name'])
            tags.update(cb.set_param(p['Name'], value))

    for name,value in sample.items():
        print('UNUSED PARAMETER:'+name)
    assert(len(sample) == 0)  # All params used

    # For testing only, the duration should be handled by the site !! Please remove before running in prod!
    # tags.update(cb.set_param("Simulation_Duration", 10*365 + 1))

    return tags

# Just for fun, let the numerical derivative baseline scale with the number of dimensions
volume_fraction = 0.0011   # desired fraction of N-sphere area to unit cube area for numerical derivative (automatic radius scaling with N)
num_params = len([p for p in params if p['Dynamic']])

if num_params == 0:
    warning_note = \
        """
        /!\\ WARNING /!\\ the OptimTool requires at least one of params with Dynamic set to True. Exiting...                  
        """
    print(warning_note)
    exit()

r = OptimTool.get_r(num_params, volume_fraction)
# it used to be r=(volume_fraction/V_n)^(1/n), which can be greater than 1 for large n(num_params > 18)
# now r = (volume_fraction * V_n)^(1/n)


optimtool = OptimTool(params,
    constrain_sample,   # <-- WILL NOT BE SAVED IN ITERATION STATE
    mu_r=r,             # <-- radius for numerical derivatve.  CAREFUL not to go too small with integer parameters
    sigma_r=r/10.,      # <-- stdev of radius
    center_repeats=1,   # <-- Number of times to replicate the center (current guess).  Nice to compare intrinsic to extrinsic noise
    samples_per_iteration=samples_per_iteration  # 32 # <-- Samples per iteration, includes center repeats.  Actual number of sims run is this number times number of sites.
)

calib_manager = CalibManager(name=expname,    # <-- Please customize this name
                             config_builder=cb,
                             map_sample_to_model_input_fn=map_sample_to_model_input,
                             sites=sites,
                             next_point=optimtool,
                             sim_runs_per_param_set=1,  # <-- Replicates
                             max_iterations=max_iterations,          # <-- Iterations
                             plotters=plotters)


run_calib_args = {
    "calib_manager": calib_manager
}

if __name__ == "__main__":
    SetupParser.init()
    cm = run_calib_args["calib_manager"]
    cm.run_calibration()
